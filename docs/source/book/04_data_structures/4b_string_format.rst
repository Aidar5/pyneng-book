Форматирование строк
====================

При работе со строками часто возникают ситуации, когда в шаблон строки
надо подставить разные данные.

Это можно делать объединяя, части строки и данные, но в Python есть
более удобный способ: форматирование строк.

Форматирование строк может помочь, например, в таких ситуациях:

* необходимо подставить значения в строку по определенному шаблону
* необходимо отформатировать вывод столбцами
* надо конвертировать числа в двоичный формат

Существует несколько вариантов форматирования строк:

* с оператором ``%`` (более старый вариант)
* метод ``format()`` (относительно новый вариант)
* f-строки - новый вариант, который появился в Python 3.6

Несмотря на то, что рекомендуется использовать метод ``format``, часто
можно встретить форматирование строк и через оператор ``%``.

Форматирование строк с методом format
-------------------------------------

Пример использования метода format:

.. code:: python

    In [1]: "interface FastEthernet0/{}".format('1')
    Out[1]: 'interface FastEthernet0/1'

Специальный символ ``{}`` указывает, что сюда подставится значение,
которое передается методу format. При этом, каждая пара фигурных скобок
обозначает одно место для подстановки.

Значения, которые подставляются в фигурные скобки, могут быть разного
типа. Например, это может быть строка, число или список:

.. code:: python

    In [3]: print('{}'.format('10.1.1.1'))
    10.1.1.1

    In [4]: print('{}'.format(100))
    100

    In [5]: print('{}'.format([10, 1, 1,1]))
    [10, 1, 1, 1]

С помощью форматирования строк можно выводить результат столбцами. В
форматировании строк можно указывать, какое количество символов выделено
на данные. Если количество символов в данных меньше, чем выделенное
количество символов, недостающие символы заполняются пробелами.

Например, таким образом можно вывести данные столбцами одинаковой ширины
по 15 символов с выравниванием по правой стороне:

.. code:: python

    In [3]: vlan, mac, intf = ['100', 'aabb.cc80.7000', 'Gi0/1']

    In [4]: print("{:>15} {:>15} {:>15}".format(vlan, mac, intf))
                100  aabb.cc80.7000           Gi0/1

Выравнивание по левой стороне:

.. code:: python

    In [5]: print("{:15} {:15} {:15}".format(vlan, mac, intf))
    100             aabb.cc80.7000  Gi0/1

Шаблон для вывода может быть и многострочным:

.. code:: python

    In [6]: ip_template = '''
       ...: IP address:
       ...: {}
       ...: '''

    In [7]: print(ip_template.format('10.1.1.1'))

    IP address:
    10.1.1.1

С помощью форматирования строк можно также влиять на отображение чисел.

Например, можно указать, сколько цифр после запятой выводить:

.. code:: python

    In [9]: print("{:.3f}".format(10.0/3))
    3.333

С помощью форматирования строк можно конвертировать числа в двоичный
формат:

.. code:: python

    In [11]: '{:b} {:b} {:b} {:b}'.format(192, 100, 1, 1)
    Out[11]: '11000000 1100100 1 1'

При этом по-прежнему можно указывать дополнительные параметры, например,
ширину столбца:

.. code:: python

    In [12]: '{:8b} {:8b} {:8b} {:8b}'.format(192, 100, 1, 1)
    Out[12]: '11000000  1100100        1        1'

А также можно указать, что надо дополнить числа нулями, вместо пробелов:

.. code:: python

    In [13]: '{:08b} {:08b} {:08b} {:08b}'.format(192, 100, 1, 1)
    Out[13]: '11000000 01100100 00000001 00000001'

В фигурных скобках можно указывать имена. Это позволяет передавать
аргументы в любом порядке, а также делает шаблон более понятным:

.. code:: python

    In [15]: '{ip}/{mask}'.format(mask=24, ip='10.1.1.1')
    Out[15]: '10.1.1.1/24'

Еще одна полезная возможность форматирования строк - указание номера
аргумента:

.. code:: python

    In [16]: '{1}/{0}'.format(24, '10.1.1.1')
    Out[16]: '10.1.1.1/24'

За счет этого, например, можно избавиться от повторной передачи одних и
тех же значений:

.. code:: python

    In [19]: ip_template = '''
        ...: IP address:
        ...: {:<8} {:<8} {:<8} {:<8}
        ...: {:08b} {:08b} {:08b} {:08b}
        ...: '''

    In [20]: print(ip_template.format(192, 100, 1, 1, 192, 100, 1, 1))

    IP address:
    192      100      1        1
    11000000 01100100 00000001 00000001

В примере выше октеты адреса приходится передавать два раза - один для
отображения в десятичном формате, а второй - для двоичного.

Указав индексы значений, которые передаются методу format, можно
избавиться от дублирования:

.. code:: python

    In [21]: ip_template = '''
        ...: IP address:
        ...: {0:<8} {1:<8} {2:<8} {3:<8}
        ...: {0:08b} {1:08b} {2:08b} {3:08b}
        ...: '''

    In [22]: print(ip_template.format(192, 100, 1, 1))

    IP address:
    192      100      1        1
    11000000 01100100 00000001 00000001

Форматирование строк с помощью f-строк
--------------------------------------

В Python 3.6 добавился новый вариант форматирования строк - f-строки или
интерполяция строк. F-строки позволяют не только подставлять какие-то
значения в шаблон, но и позволяют выполнять вызовы функций, методов и
тп.

Во многих ситуациях f-строки удобней и проще использовать, чем format,
кроме того, f-строки работают быстрее, чем format и другие методы
форматирования строк.

.. warning::
    
    В примерах про f-строки используются методы, которые еще не рассматривались,
    для того чтобы показать возможности f-строк.
    При необходимости, можно сначала почитать 4 раздел, а затем вернуться к f-строкам.

Синтаксис
~~~~~~~~~

F-строки - это литерал строки с буквой ``f`` перед ним. Внутри f-строки
в паре фигурных скобок указываются имена переменных, которые надо
подставить:

.. code:: python

    In [1]: ip = '10.1.1.1'

    In [2]: mask = 24

    In [3]: f"IP: {ip}, mask: {mask}"
    Out[3]: 'IP: 10.1.1.1, mask: 24'

    Аналогичный результат с format можно получить так:
    ``"IP: {ip}, mask: {mask}".format(ip=ip, mask=mask)``.

Очень важное отличие f-строк от format: f-строки это выражение, которое
выполняется, а не просто строка. То есть, в случае с ipython, как только
мы написали выражение и нажали Enter, оно выполнилось и вместо выражений
``{name}`` и ``{mask}`` подставились значения переменных.

Поэтому, например, нельзя сначала написать шаблон, а затем определить
переменные, которые используются в шаблоне:

.. code:: python

    In [1]: f"IP: {ip}, mask: {mask}"
    ---------------------------------------------------------------------------
    NameError                                 Traceback (most recent call last)
    <ipython-input-1-e6f8e01ac9c4> in <module>()
    ----> 1 f"IP: {ip}, mask: {mask}"

    NameError: name 'ip' is not defined

Кроме подстановки значений переменных, в фигурных скобках можно писать
выражения:

.. code:: python

    In [1]: octets = ['10', '1', '1', '1']

    In [2]: mask = 24

    In [3]: f"IP: {'.'.join(octets)}, mask: {mask}"
    Out[3]: 'IP: 10.1.1.1, mask: 24'

После двоеточия в f-строках можно указывать те же значения, что и при
использовании format:

.. code:: python

    In [9]: oct1, oct2, oct3, oct4 = [10, 1, 1, 1]

    In [10]: print(f'''
        ...: IP address:
        ...: {oct1:<8} {oct2:<8} {oct3:<8} {oct4:<8}
        ...: {oct1:08b} {oct2:08b} {oct3:08b} {oct4:08b}''')

    IP address:
    10       1        1        1
    00001010 00000001 00000001 00000001

Особенности использования f-строк
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

При использовании f-строк нельзя сначала создать шаблон, а затем его
использовать, как при использовании format.

F-строка сразу выполняется и в нее подставляются значения переменных,
которые должны быть определены ранее:

.. code:: python

    In [7]: ip = '10.1.1.1'

    In [8]: mask = 24

    In [9]: print(f"IP: {ip}, mask: {mask}")
    IP: 10.1.1.1, mask: 24

Если необходимо подставить другие значения, надо создать новые
переменные и снова написать f-строку:

.. code:: python

    In [11]: ip = '10.2.2.2'

    In [12]: mask = 24

    In [13]: ip = '10.2.2.2'

    In [14]: print(f"IP: {ip}, mask: {mask}")
    IP: 10.2.2.2, mask: 24


При использовании f-строк в циклах, f-строку надо писать в теле цикла,
чтобы она "подхватывала" новые значения переменных на каждой итерации:

.. code:: python

    In [1]: ip_list = ['10.1.1.1/24', '10.2.2.2/24', '10.3.3.3/24']

    In [2]: for ip_address in ip_list:
       ...:     ip, mask = ip_address.split('/')
       ...:     print(f"IP: {ip}, mask: {mask}")
       ...:
    IP: 10.1.1.1, mask: 24
    IP: 10.2.2.2, mask: 24
    IP: 10.3.3.3, mask: 24

Примеры использования f-строк
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Базовая подстановка переменных:

.. code:: python

    In [1]: intf_type = 'Gi'

    In [2]: intf_name = '0/3'

    In [3]: f'interface {intf_type}/{intf_name}'
    Out[3]: 'interface Gi/0/3'

Выравнивание столбцами:

.. code:: python

    In [6]: topology = [['sw1', 'Gi0/1', 'r1', 'Gi0/2'],
       ...:             ['sw1', 'Gi0/2', 'r2', 'Gi0/1'],
       ...:             ['sw1', 'Gi0/3', 'r3', 'Gi0/0'],
       ...:             ['sw1', 'Gi0/5', 'sw4', 'Gi0/2']]
       ...:

    In [7]: for connection in topology:
       ...:     l_device, l_port, r_device, r_port = connection
       ...:     print(f'{l_device:10} {l_port:7} {r_device:10} {r_port:7}')
       ...:
    sw1        Gi0/1   r1         Gi0/2
    sw1        Gi0/2   r2         Gi0/1
    sw1        Gi0/3   r3         Gi0/0
    sw1        Gi0/5   sw4        Gi0/2

Ширина столбцов может быть указана через переменную:

.. code:: python

    In [6]: topology = [['sw1', 'Gi0/1', 'r1', 'Gi0/2'],
       ...:             ['sw1', 'Gi0/2', 'r2', 'Gi0/1'],
       ...:             ['sw1', 'Gi0/3', 'r3', 'Gi0/0'],
       ...:             ['sw1', 'Gi0/5', 'sw4', 'Gi0/2']]
       ...:

    In [7]: width = 10

    In [8]: for connection in topology:
       ...:     l_device, l_port, r_device, r_port = connection
       ...:     print(f'{l_device:{width}} {l_port:{width}} {r_device:{width}} {r_port:{width}}')
       ...:
    sw1        Gi0/1      r1         Gi0/2
    sw1        Gi0/2      r2         Gi0/1
    sw1        Gi0/3      r3         Gi0/0
    sw1        Gi0/5      sw4        Gi0/2

Работа со словарями

.. code:: python

    In [1]: session_stats = {'done': 10, 'todo': 5}

    In [2]: if session_stats['todo']:
       ...:     print(f"Pomodoros done: {session_stats['done']}, TODO: {session_stats['todo']}")
       ...: else:
       ...:     print(f"Good job! All {session_stats['done']} pomodoros done!")
       ...:
    Pomodoros done: 10, TODO: 5

Вызов функции len внутри f-строки:

.. code:: python

    In [2]: topology = [['sw1', 'Gi0/1', 'r1', 'Gi0/2'],
       ...:             ['sw1', 'Gi0/2', 'r2', 'Gi0/1'],
       ...:             ['sw1', 'Gi0/3', 'r3', 'Gi0/0'],
       ...:             ['sw1', 'Gi0/5', 'sw4', 'Gi0/2']]
       ...:

    In [3]: print(f'Количество подключений в топологии: {len(topology)}')
    Количество подключений в топологии: 4

Вызов метода upper внутри f-строки:

.. code:: python

    In [1]: name = 'python'

    In [2]: print(f'Zen of {name.upper()}')
    Zen of PYTHON

Конвертация чисел в двоичный формат:

.. code:: python

    In [7]: ip = '10.1.1.1'

    In [8]: oct1, oct2, oct3, oct4 = ip.split('.')

    In [9]: print(f'{int(oct1):08b} {int(oct2):08b} {int(oct3):08b} {int(oct4):08b}')
    00001010 00000001 00000001 00000001

Что использовать format или f-строки
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Во многих случаях f-строки удобней использовать, так как шаблон выглядит
понятней и компактней. Однако, бывают случаи, когда метод format
удобней. Например:

.. code:: python

    In [6]: ip = [10, 1, 1, 1]

    In [7]: oct1, oct2, oct3, oct4 = ip
       ...: print(f'{oct1:08b} {oct2:08b} {oct3:08b} {oct4:08b}')
       ...:
    00001010 00000001 00000001 00000001

    In [8]: template = "{:08b} "*4

    In [9]: template.format(*ip)
    Out[9]: '00001010 00000001 00000001 00000001 '

Еще одна ситуация, когда format, как правило, удобней использовать:
необходимость использовать в скрипте один и тот же шаблон много раз.
F-строка выполнится первый раз и подставит текущие значения переменных и
для использования шаблона еще раз, его надо заново писать. Это значит,
что в скрипте будут находится копии одной и то же строки. В то же время
format позволяет создать шаблон в одном месте и потом использовать его
повторно, подставляя переменные по мере необходимости.

Это можно обойти создав функцию, но создавать функцию для вывода строки
по шаблону далеко не всегда оправдано. Пример создания функции:

.. code:: python

    In [1]: def show_me_ip(ip, mask):
       ...:     return f"IP: {ip}, mask: {mask}"
       ...:

    In [2]: show_me_ip('10.1.1.1', 24)
    Out[2]: 'IP: 10.1.1.1, mask: 24'

    In [3]: show_me_ip('192.16.10.192', 28)
    Out[3]: 'IP: 192.16.10.192, mask: 28'

