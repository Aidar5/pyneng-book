Задания
=======

{% include "../exercises\_intro.md" %}

Задание 17.1
~~~~~~~~~~~~

В этом задании нужно: \* взять содержимое нескольких файлов с выводом
команды sh version \* распарсить вывод команды с помощью регулярных
выражений и получить информацию об устройстве \* записать полученную
информацию в файл в CSV формате

Для выполнения задания нужно создать две функции.

Функция parse\_sh\_version: \* ожидает аргумент output в котором
находится вывод команды sh version (не имя файла) \* обрабатывает вывод,
с помощью регулярных выражений \* возвращает кортеж из трёх элементов:
\* ios - в формате "12.4(5)T" \* image - в формате
"flash:c2800-advipservicesk9-mz.124-5.T.bin" \* uptime - в формате "5
days, 3 hours, 3 minutes"

Функция write\_to\_csv: \* ожидает два аргумента: \* имя файла, в
который будет записана информация в формате CSV \* данные в виде списка
списков, где: \* первый список - заголовки столбцов, \* остальные списки
- содержимое \* функция записывает содержимое в файл, в формате CSV и
ничего не возвращает

Остальное содержимое скрипта может быть в скрипте, а может быть в ещё
одной функции.

Скрипт должен: \* обработать информацию из каждого файла с выводом sh
version: \* sh\_version\_r1.txt, sh\_version\_r2.txt,
sh\_version\_r3.txt \* с помощью функции parse\_sh\_version, из каждого
вывода должна быть получена информация ios, image, uptime \* из имени
файла нужно получить имя хоста \* после этого вся информация должна быть
записана в файл routers\_inventory.csv

В файле routers\_inventory.csv должны быть такие столбцы: \* hostname,
ios, image, uptime

В скрипте, с помощью модуля glob, создан список файлов, имя которых
начинается на sh\_vers. Вы можете раскомментировать строку
print(sh\_version\_files), чтобы посмотреть содержимое списка.

Кроме того, создан список заголовков (headers), который должен быть
записан в CSV.

.. code:: python

    import glob

    sh_version_files = glob.glob('sh_vers*')
    #print(sh_version_files)

    headers = ['hostname', 'ios', 'image', 'uptime']

Задание 17.2
~~~~~~~~~~~~

Создать функцию parse\_sh\_cdp\_neighbors, которая обрабатывает вывод
команды show cdp neighbors.

Функция ожидает, как аргумент, вывод команды одной строкой (не имя
файла).

Функция должна возвращать словарь, который описывает соединения между
устройствами.

Например, если как аргумент был передан такой вывод:

::

    R4>show cdp neighbors

    Device ID    Local Intrfce   Holdtme     Capability       Platform    Port ID
    R5           Fa 0/1          122           R S I           2811       Fa 0/1
    R6           Fa 0/2          143           R S I           2811       Fa 0/0

Функция должна вернуть такой словарь:

.. code:: python

    {'R4': {'Fa0/1': {'R5': 'Fa0/1'},
            'Fa0/2': {'R6': 'Fa0/0'}}}

При этом интерфейсы могут быть записаны с пробелом Fa 0/0 или без Fa0/0.

Проверить работу функции на содержимом файла sh\_cdp\_n\_sw1.txt

Задание 17.2a
~~~~~~~~~~~~~

С помощью функции parse\_sh\_cdp\_neighbors из задания 17.2, обработать
вывод команды sh cdp neighbor из файлов: \* sh\_cdp\_n\_sw1.txt \*
sh\_cdp\_n\_r1.txt \* sh\_cdp\_n\_r2.txt \* sh\_cdp\_n\_r3.txt \*
sh\_cdp\_n\_r4.txt \* sh\_cdp\_n\_r5.txt \* sh\_cdp\_n\_r6.txt

Объединить все словари, которые возвращает функция
parse\_sh\_cdp\_neighbors, в один словарь topology и записать его
содержимое в файл topology.yaml.

Структура словаря topology должна быть такой:

.. code:: python

    {'R4': {'Fa0/1': {'R5': 'Fa0/1'},
            'Fa0/2': {'R6': 'Fa0/0'}},
     'R5': {'Fa0/1': {'R4': 'Fa0/1'}},
     'R6': {'Fa0/0': {'R4': 'Fa0/2'}}}

При этом интерфейсы могут быть записаны с пробелом Fa 0/0 или без Fa0/0.

Не копировать код функции parse\_sh\_cdp\_neighbors

Задание 17.2b
~~~~~~~~~~~~~

Переделать функциональность скрипта из задания 17.2a, в функцию
generate\_topology\_from\_cdp.

Функция generate\_topology\_from\_cdp должна быть создана с параметрами:
\* list\_of\_files - список файлов из которых надо считать вывод команды
sh cdp neighbor \* save\_to\_file - этот параметр управляет тем, будет
ли записан в файл, итоговый словарь \* значение по умолчанию - True \*
topology\_filename - имя файла, в который сохранится топология. \* по
умолчанию, должно использоваться имя topology.yaml. \* топология
сохраняется только, если аргумент save\_to\_file указан равным True

Функция возвращает словарь, который описывает топологию. Словарь должен
быть в том же формате, что и в задании 17.2a.

Проверить работу функции generate\_topology\_from\_cdp на файлах: \*
sh\_cdp\_n\_sw1.txt \* sh\_cdp\_n\_r1.txt \* sh\_cdp\_n\_r2.txt \*
sh\_cdp\_n\_r3.txt \* sh\_cdp\_n\_r4.txt \* sh\_cdp\_n\_r5.txt \*
sh\_cdp\_n\_r6.txt

Записать полученный словарь в файл topology.yaml.

Не копировать код функции parse\_sh\_cdp\_neighbors

Задание 17.2c
~~~~~~~~~~~~~

С помощью функции draw\_topology из файла draw\_network\_graph.py
сгенерировать топологию, которая соответствует описанию в файле
topology.yaml

Обратите внимание на то, какой формат данных ожидает функция
draw\_topology. Описание топологии из файла topology.yaml нужно
преобразовать соответствующим образом, чтобы использовать функцию
draw\_topology.

Для решения задания можно создать любые вспомогательные функции.

Не копировать код функции draw\_topology.

В итоге, должно быть сгенерировано изображение топологии. Результат
должен выглядеть так же, как схема в файле task\_17\_2c\_topology.svg

.. figure:: https://raw.githubusercontent.com/natenka/PyNEng/master/images/10_serialization/task_10_2c_topology.png
   :alt: task\_10\_2c\_topology

   task\_10\_2c\_topology
При этом: \* Интерфейсы могут быть записаны с пробелом Fa 0/0 или без
Fa0/0. \* Расположение устройств на схеме может быть другим \*
Соединения должны соответствовать схеме

    Для выполнения этого задания, должен быть установлен graphviz:
    ``apt-get install graphviz``

    И модуль python для работы с graphviz: ``pip install graphviz``
