Задания
=======

{% include "../exercises\_intro.md" %}

Задание 22.1
~~~~~~~~~~~~

Переделать пример, который использовался в разделе TextFSM, в функцию.

Функция должна называться parse\_output. Параметры функции: \* template
- шаблон TextFSM (это должно быть имя файла, в котором находится шаблон)
\* output - вывод соответствующей команды show (строка)

Функция должна возвращать список: \* первый элемент - это список с
названиями столбцов (в примере ниже, находится в переменной header) \*
остальные элементы это списки, в которых находятся результаты обработки
вывода (в примере ниже, находится в переменной result)

Проверить работу функции на каком-то из примеров раздела.

Пример из раздела:

.. code:: python

    import sys
    import textfsm
    from tabulate import tabulate

    template = sys.argv[1]
    output_file = sys.argv[2]

    with open(template) as f, open(output_file) as output:
        re_table = textfsm.TextFSM(f)
        header = re_table.header
        result = re_table.ParseText(output.read())
        print(result)
        print(tabulate(result, headers=header))

Задание 22.1a
~~~~~~~~~~~~~

Переделать функцию parse\_output из задания 22.1 таким образом, чтобы,
вместо списка списков, она возвращала один список словарей: \* ключи -
названия столбцов, \* значения, соответствующие значения в столбцах.

То есть, для каждой строки будет один словарь в списке.

Задание 22.2
~~~~~~~~~~~~

В этом задании нужно использовать функцию parse\_output из задания 22.1.
Она используется для того, чтобы получить структурированный вывод в
результате обработки вывода команды.

Полученный вывод нужно записать в CSV формате.

Для записи вывода в CSV, нужно создать функцию list\_to\_csv, которая
ожидает как аргументы: \* список: \* первый элемент - это список с
названиями заголовков \* остальные элементы это списки, в котором
находятся результаты обработки вывода \* имя файла, в который нужно
записать данные в CSV формате

Проверить работу функции на примере обработки команды sh ip int br
(шаблон и вывод есть в разделе).

Задание 22.3
~~~~~~~~~~~~

Сделать шаблон TextFSM для обработки вывода sh ip dhcp snooping binding.
Вывод команды находится в файле output/sh\_ip\_dhcp\_snooping.txt.

Шаблон должен обрабатывать и возвращать значения таких столбцов: \*
MacAddress \* IpAddress \* VLAN \* Interface

Проверить работу шаблона с помощью функции из задания 22.1.

Задание 22.4
~~~~~~~~~~~~

На основе примера из раздела
`clitable <../../book/22_textfsm/3_textfsm_clitable.md>`__ сделать
функцию parse\_command\_dynamic.

Параметры функции: \* словарь атрибутов, в котором находятся такие пары
ключ: значение: \* 'Command': команда \* 'Vendor': вендор (обратите
внимание, что файл index отличается от примера, который использовался в
разделе, поэтому Вам нужно подставить тут правильное значение) \* имя
файла, где хранится соответствие между командами и шаблонами (строка) \*
значение по умолчанию аргумента - index \* каталог, где хранятся шаблоны
и файл с соответствиями (строка) \* значение по умолчанию аргумента -
templates \* вывод команды (строка)

Функция должна возвращать список словарей с результатами обработки
вывода команды (как в задании 22.1a): \* ключи - названия столбцов \*
значения - соответствующие значения в столбцах

Проверить работу функции на примере вывода команды sh ip int br.

Пример из раздела:

.. code:: python

    import clitable

    output_sh_ip_route_ospf = open('output/sh_ip_route_ospf.txt').read()

    cli_table = clitable.CliTable('index', 'templates')
    attributes = {'Command': 'show ip route ospf', 'Vendor': 'Cisco'}

    cli_table.ParseCmd(output_sh_ip_route_ospf, attributes)

    print('CLI Table output:\n', cli_table)
    print('Formatted Table:\n', cli_table.FormattedTable())

    data_rows = [list(row) for row in cli_table]
    header = list(cli_table.header)

    print(header)
    for row in data_rows:
        print(row)

Задание 22.4a
~~~~~~~~~~~~~

Переделать функцию из задания 22.4: \* добавить аргумент show\_output,
который контролирует будет ли выводиться результат обработки команды на
стандартный поток вывода \* по умолчанию False, что значит результат не
будет выводиться \* результат должен отображаться с помощью
FormattedTable (пример есть в разделе)

Задание 22.5
~~~~~~~~~~~~

В этом задании соединяется функциональность TextFSM и подключение к
оборудованию.

Задача такая: \* подключиться к оборудованию \* выполнить команду show
\* полученный вывод передавать на обработку TextFSM \* вернуть результат
обработки

Для этого, воспользуемся функциями, которые были созданы ранее: \*
функцией send\_show\_command из упражнения 19.1 \* функцией
parse\_command\_dynamic из упражнения 22.4

В этом упражнении нужно создать функцию send\_and\_parse\_command: \*
функция должна использовать внутри себя функции parse\_command\_dynamic
и send\_show\_command. \* какие аргументы должны быть у функции
send\_and\_parse\_command, нужно решить самостоятельно \* но, надо иметь
в виду, какие аргументы ожидают две готовые функции, которые мы
используем \* функция send\_and\_parse\_command должна возвращать: \*
функция send\_show\_command возвращает словарь с результатами выполнения
команды: \* ключ - IP устройства \* значение - результат выполнения
команды \* затем, нужно отправить полученный вывод на обработку функции
parse\_command\_dynamic \* в результате, должен получиться словарь, в
котором: \* ключ - IP устройства \* значение - список словарей (то есть,
тот вывод, который был получен из функции parse\_command\_dynamic)

Для функции send\_show\_command создан файл devices.yaml, в котором
находятся параметры подключения к устройствам.

Проверить работу функции send\_and\_parse\_command на команде sh ip int
br.

Задание 22.6
~~~~~~~~~~~~

Это задание похоже на задание 22.5, но в этом задании подключения надо
выполнять параллельно с помощью потоков. Для параллельного подключения
использовать модуль concurrent.futures.

В этом упражнении нужно создать функцию
send\_and\_parse\_command\_parallel: \* она должна использовать внутри
себя функцию send\_and\_parse\_command \* какие аргументы должны быть у
функции send\_and\_parse\_command\_parallel, нужно решить самостоятельно
\* функция send\_and\_parse\_command\_parallel должна возвращать
словарь, в котором: \* ключ - IP устройства \* значение - список
словарей

Проверить работу функции send\_and\_parse\_command\_parallel на команде
sh ip int br.

::

    import yaml

    test_command = "sh ip int br"
    devices = yaml.load(open('devices.yaml'))

